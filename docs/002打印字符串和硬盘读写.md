## 一、打印字符串

```s
[bits 16]

mov ax,3
int 0x10

mov ax,0
mov dx,ax
mov es,ax
mov ss,ax
mov sp,0x7c00

mov si,booting
call print
jmp $

print:
    mov ah,0x0e
.next:
    mov al,[si]
    cmp al,0
    jz .done
    int 0x10
    inc si
    jmp .next

.done:
    ret

booting db "===Booting ecpos...====",10,13,0
times 510-($-$$) db 0
db 0x55,0xaa

```

就是将需要打印的字符串给si，调用int 0x03中断，打印字符，自增si循环打印，直到[si]为0


## 二、打印字符串

```c
LOADER_SEG      equ 0x0800      ; Stage 2加载到0x8000
LOADER_OFFSET   equ 0x0000
LOADER_SECTOR   equ 1           ; Stage 2起始扇区（紧跟MBR）
LOADER_COUNT    equ 4           ; Stage 2占用4个扇区



mov ah, 0x02                ; BIOS读取扇区功能
mov al, LOADER_COUNT        ; 读取扇区数
mov ch, 0                   ; 柱面0
mov cl, LOADER_SECTOR       ; 扇区号（从1开始，所以+1）
mov dh, 0                   ; 磁头0
mov dl, [BOOT_DRIVE]        ; 驱动器号
mov bx, LOADER_SEG          ; ES:BX = 目标地址
mov es, bx
xor bx, bx

int 0x13                    ; 调用BIOS

jc disk_error               ; CF=1表示错误

; 检查实际读取的扇区数
cmp al, LOADER_COUNT
jne disk_error

; 成功
mov si, msg_ok
call print


; 跳转！
jmp LOADER_SEG:LOADER_OFFSET

jmp $

disk_error:
    mov si, msg_fail
    call print
    jmp $
```




这段代码使用了传统的 **BIOS CHS (Cylinder-Head-Sector) 读取功能 ($AH=0x02$)**。
-----
### 1\. 常量定义 (`equ`)

这是定义 Stage 2 Loader 的加载目标地址、起始位置和大小：

| 常量 | 值 | 含义 |
| :--- | :--- | :--- |
| `LOADER_SEG` | `0x0800` | Stage 2 代码要加载到的**段地址**。物理地址是 $0x0800 \times 16 = 0x8000$。 |
| `LOADER_OFFSET` | `0x0000` | Stage 2 代码的**偏移地址**。|
| `LOADER_SECTOR` | `1` | Stage 2 代码在磁盘上的起始**扇区号**。**注意：** 在 CHS 模式下，扇区号从 1 开始计数。LBA 0 对应 CHS 扇区 1，LBA 1 对应 CHS 扇区 2。如果您想读取 LBA 1，这个值应该是 2。|
| `LOADER_COUNT` | `4` | 需要读取的**扇区数量**（$4$ 个扇区 $\times 512$ 字节/扇区 $= 2048$ 字节）。 |

### 2\. 初始化 (`mov ax,3` 到 `call print`)

这是引导扇区的标准启动流程：

1.  **清屏/设置模式：**
    ```assembly
    mov ax,3
    int 0x10
    ```
    调用 BIOS $0x10$ 视频中断，设置视频模式（通常是 80x25 文本模式），并清屏。
2.  **设置段寄存器和堆栈：**
    ```assembly
    mov ax,0
    mov dx,ax
    mov es,ax
    mov ss,ax
    mov sp,0x7c00
    ```
      * 这段代码尝试将 $ES$ 设置为 $0x0000$。但通常 $DS, ES, SS$ 会被设置为 $0x7c00$（代码当前所在的段）。
      * 将堆栈指针 $SP$ 设置为 $0x7c00$，让堆栈向下增长（从 $0x7c00$ 开始）。这是在 16 位实模式下引导扇区设置堆栈的常见做法。
3.  **显示启动信息：**
    ```assembly
    mov si,booting
    call print
    ```
    调用 `print` 子程序显示启动消息 `===Booting ecpos...====`。

### 3\. BIOS CHS 磁盘读取 (`mov ah, 0x02` 到 `int 0x13`)

这是加载 Stage 2 的核心逻辑：

1.  **设置功能号和扇区数：**
    ```assembly
    mov ah, 0x02                ; BIOS 读取扇区功能 (AH=0x02)
    mov al, LOADER_COUNT        ; 读取 4 个扇区
    ```
2.  **设置 CHS 地址：**
    ```assembly
    mov ch, 0                   ; 柱面 C = 0 (CH)
    mov cl, LOADER_SECTOR       ; 扇区 S = 1 (CL) <-- 如果目标是 LBA 1，此处应为 2
    mov dh, 0                   ; 磁头 H = 0 (DH)
    mov dl, [BOOT_DRIVE]        ; 驱动器号 DL = [0x00] (软盘)
    ```
      * **注意：** 扇区号 $CL$ 包含扇区号（低 6 位）和柱面高 2 位。由于 $CH=0$，这里只需要关注扇区号。
3.  **设置目标地址 $ES:BX$：**
    ```assembly
    mov bx, LOADER_SEG          ; BX = 0x0800
    mov es, bx                  ; ES = 0x0800
    xor bx, bx                  ; BX = 0x0000 (将偏移量设为 0)
    ```
      * 设置目标地址 $ES:BX = 0x0800:0x0000$（物理地址 $0x8000$）。
4.  **调用中断：**
    ```assembly
    int 0x13                    ; 调用 BIOS 磁盘服务
    ```

### 4\. 错误检查与跳转 (`jc disk_error` 到 `jmp LOADER_SEG:LOADER_OFFSET`)

1.  **检查 CF 错误标志：**
    ```assembly
    jc disk_error               ; CF=1 表示 BIOS 读取失败
    ```
2.  **检查读取扇区数：**
    ```assembly
    cmp al, LOADER_COUNT
    jne disk_error
    ```
    BIOS 将实际读取的扇区数放在 $AL$ 中。如果 $AL$ 不等于请求的数量 ($4$)，则视为错误。
3.  **成功跳转：**
    ```assembly
    mov si, msg_ok
    call print
    mov dl, [BOOT_DRIVE]        ; 重新设置 DL (传递给 Stage 2)
    jmp LOADER_SEG:LOADER_OFFSET; 跳转到 0x8000 处执行 Stage 2 代码
    ```

### 5\. 辅助功能和数据

  * **`disk_error`：** 打印错误信息 `DISK READ FAILED!`，然后进入死循环 (`jmp $`)。
  * **`print`：** 字符打印子程序，使用 $AH=0x0E$ 的 BIOS $0x10$ TTY 输出功能。
  * **数据段：** 定义了各种字符串和关键配置变量 `BOOT_DRIVE db 0x00`（软盘）。
  * **MBR 签名：** 最后的 $512$ 字节填充和引导扇区魔数 $0x55AA$。

-----

这是将当前扇区读取到0x8000的位置，可以使用`-exec x/512bx 0x8000`查看硬盘是否读取成功
